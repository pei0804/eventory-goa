// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/tikasan/eventory-goa/design
// --out=$(GOPATH)/src/github.com/tikasan/eventory-goa
// --version=v1.1.0-dirty
//
// API "eventory": Application Media Types
//
// The content of this file is auto-generated, DO NOT MODIFY

package client

import (
	"github.com/goadesign/goa"
	"net/http"
)

// イベント情報 (default view)
//
// Identifier: application/vnd.event+json; view=default
type Event struct {
	// ID
	ID int `form:"ID" json:"ID" xml:"ID"`
	// 参加登録済み人数
	Accepted int `form:"accepted" json:"accepted" xml:"accepted"`
	// APIの種類
	APIID string `form:"apiID" json:"apiID" xml:"apiID"`
	// 参加人数上限
	Limit int `form:"limit" json:"limit" xml:"limit"`
	// 開催地
	Place string `form:"place" json:"place" xml:"place"`
	// 開催地
	StartAt string `form:"startAt" json:"startAt" xml:"startAt"`
	// イベント名
	Title string `form:"title" json:"title" xml:"title"`
	// 開催地
	UpdatedAt string `form:"updatedAt" json:"updatedAt" xml:"updatedAt"`
	// イベントページURL
	URL string `form:"url" json:"url" xml:"url"`
	// キャンセル待ち人数
	Waitlisted int `form:"waitlisted" json:"waitlisted" xml:"waitlisted"`
}

// Validate validates the Event media type instance.
func (mt *Event) Validate() (err error) {

	if mt.APIID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "apiID"))
	}
	if mt.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "title"))
	}
	if mt.URL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}

	if mt.Place == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "place"))
	}
	if mt.StartAt == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "startAt"))
	}
	if mt.UpdatedAt == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "updatedAt"))
	}
	return
}

// DecodeEvent decodes the Event instance encoded in resp body.
func (c *Client) DecodeEvent(resp *http.Response) (*Event, error) {
	var decoded Event
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// EventCollection is the media type for an array of Event (default view)
//
// Identifier: application/vnd.event+json; type=collection; view=default
type EventCollection []*Event

// Validate validates the EventCollection media type instance.
func (mt EventCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeEventCollection decodes the EventCollection instance encoded in resp body.
func (c *Client) DecodeEventCollection(resp *http.Response) (EventCollection, error) {
	var decoded EventCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// ジャンル (default view)
//
// Identifier: application/vnd.genre+json; view=default
type Genre struct {
	// ジャンルID
	ID *int `form:"ID,omitempty" json:"ID,omitempty" xml:"ID,omitempty"`
	// ジャンル名
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// DecodeGenre decodes the Genre instance encoded in resp body.
func (c *Client) DecodeGenre(resp *http.Response) (*Genre, error) {
	var decoded Genre
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// GenreCollection is the media type for an array of Genre (default view)
//
// Identifier: application/vnd.genre+json; type=collection; view=default
type GenreCollection []*Genre

// DecodeGenreCollection decodes the GenreCollection instance encoded in resp body.
func (c *Client) DecodeGenreCollection(resp *http.Response) (GenreCollection, error) {
	var decoded GenreCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeErrorResponse decodes the ErrorResponse instance encoded in resp body.
func (c *Client) DecodeErrorResponse(resp *http.Response) (*goa.ErrorResponse, error) {
	var decoded goa.ErrorResponse
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}
